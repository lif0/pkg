name: ðŸš€ Create Module Release

on:
  workflow_dispatch:
    inputs:
      module:
        description: "Override module name (optional, else parsed from branch '<module>/<version>')"
        required: false
      version:
        description: "Override version (optional, e.g. v1.2.3; 'v' will be added if missing)"
        required: false
      tag_template:
        description: "Tag template. Use {module} and {version}. Example: {module}-{version} or {version}"
        required: false
        default: "{module}-{version}"
      make_latest:
        description: "Mark as latest? (monorepo usually 'false')"
        type: choice
        options: ["false", "true", "legacy"]
        default: "false"
      prerelease:
        description: "Mark as prerelease? Leave empty to auto-detect by version suffix (e.g. -rc.1)"
        required: false

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout branch
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}

      - name: Parse module & version from branch or inputs
        id: parse
        shell: bash
        run: |
          set -euo pipefail
          ref_name="${GITHUB_REF_NAME}"
          input_module="${{ inputs.module || '' }}"
          input_version="${{ inputs.version || '' }}"
          tag_tmpl="${{ inputs.tag_template || '{module}-{version}' }}"
          make_latest="${{ inputs.make_latest || 'false' }}"
          input_prerelease="${{ inputs.prerelease || '' }}"

          module="$input_module"
          version="$input_version"

          if [[ -z "$module" || -z "$version" ]]; then
            # Expect branch format "<module>/<version>"
            if [[ "$ref_name" =~ ^([^/]+)/(.+)$ ]]; then
              [[ -z "$module" ]] && module="${BASH_REMATCH[1]}"
              [[ -z "$version" ]] && version="${BASH_REMATCH[2]}"
            fi
          fi

          if [[ -z "$module" || -z "$version" ]]; then
            echo "::error::Cannot determine module/version. Either run from a branch named '<module>/<version>' (e.g. concurrency/v1.0.0) or provide 'module' and 'version' inputs."
            exit 1
          fi

          # Normalize version: add leading 'v' if missing
          if [[ ! "$version" =~ ^v ]]; then
            version="v${version}"
          fi

          # Basic semver acceptance: vMAJOR.MINOR.PATCH with optional -prerelease[.N]
          if [[ ! "$version" =~ ^v[0-9]+(\.[0-9]+){2}([-+][0-9A-Za-z\.-]+)?$ ]]; then
            echo "::warning::Version '$version' does not look like SemVer. Proceeding anyway."
          fi

          # Render tag from template
          tag="${tag_tmpl//\{module\}/$module}"
          tag="${tag//\{version\}/$version}"

          # Auto-detect prerelease if not explicitly provided
          prerelease="false"
          if [[ -n "$input_prerelease" ]]; then
            # normalize to 'true'/'false'
            shopt -s nocasematch
            if [[ "$input_prerelease" =~ ^(1|true|yes|y)$ ]]; then prerelease="true"; fi
            if [[ "$input_prerelease" =~ ^(0|false|no|n)$ ]]; then prerelease="false"; fi
            shopt -u nocasematch
          else
            if [[ "$version" =~ - ]]; then prerelease="true"; fi
          fi

          echo "module=$module" >> "$GITHUB_OUTPUT"
          echo "version=$version" >> "$GITHUB_OUTPUT"
          echo "tag=$tag" >> "$GITHUB_OUTPUT"
          echo "name=${module} ${version}" >> "$GITHUB_OUTPUT"
          echo "make_latest=$make_latest" >> "$GITHUB_OUTPUT"
          echo "prerelease=$prerelease" >> "$GITHUB_OUTPUT"

      - name: Detect module path (packages/<module>, modules/<module>, or <module>)
        id: path
        shell: bash
        run: |
          set -euo pipefail
          module="${{ steps.parse.outputs.module }}"
          path=""
          for candidate in "packages/$module" "modules/$module" "$module"; do
            if [[ -d "$candidate" ]]; then
              path="$candidate"
              break
            fi
          done
          if [[ -n "$path" ]]; then
            echo "path=$path" >> "$GITHUB_OUTPUT"
            echo "Found module path: $path"
          else
            echo "path=" >> "$GITHUB_OUTPUT"
            echo "::notice::No dedicated directory found for module '${module}'. Release notes will include all commits on this branch."
          fi

      - name: Find previous module tag
        id: prev
        shell: bash
        run: |
          set -euo pipefail
          module="${{ steps.parse.outputs.module }}"
          version="${{ steps.parse.outputs.version }}"
          tag="${{ steps.parse.outputs.tag }}"
          # Build a glob like '<module>-*' from the current tag by replacing the version with '*'
          glob="$tag"
          glob="${glob//$version/*}"
          prev_tag="$(git tag --list "$glob" --sort=-v:refname | head -n1 || true)"
          if [[ -n "$prev_tag" ]]; then
            echo "prev_tag=$prev_tag" >> "$GITHUB_OUTPUT"
            echo "Previous tag: $prev_tag"
          else
            echo "prev_tag=" >> "$GITHUB_OUTPUT"
            echo "No previous tag found matching '$glob'."
          fi

      - name: Generate module-specific release notes
        id: notes
        shell: bash
        run: |
          set -euo pipefail
          path="${{ steps.path.outputs.path }}"
          prev="${{ steps.prev.outputs.prev_tag }}"
          notes_file="release_notes.md"

          range=""
          if [[ -n "$prev" ]]; then
            range="$prev..HEAD"
          else
            # First release for this module: include history on this branch only
            range=""
          fi

          {
            echo "# Changes for ${{ steps.parse.outputs.module }} ${{ steps.parse.outputs.version }}"
            echo
            if [[ -n "$prev" ]]; then
              echo "_Compared to **$prev**_"
              echo
            fi
            echo "## Commits"
            if [[ -n "$path" ]]; then
              if [[ -n "$range" ]]; then
                git log --no-merges --pretty=format:'- %s (%h) by %an' $range -- "$path" || true
              else
                git log --no-merges --pretty=format:'- %s (%h) by %an' -- "$path" || true
              fi
            else
              if [[ -n "$range" ]]; then
                git log --no-merges --pretty=format:'- %s (%h) by %an' $range || true
              else
                git log --no-merges --pretty=format:'- %s (%h) by %an' || true
              fi
            fi
          } > "$notes_file"

          if ! grep -q " - " "$notes_file"; then
            echo "- Initial release." >> "$notes_file"
          fi

          echo "file=$notes_file" >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.parse.outputs.tag }}
          name: ${{ steps.parse.outputs.name }}
          target_commitish: ${{ github.sha }}
          body_path: ${{ steps.notes.outputs.file }}
          generate_release_notes: false
          make_latest: ${{ steps.parse.outputs.make_latest }}
          draft: false
          prerelease: ${{ steps.parse.outputs.prerelease }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}